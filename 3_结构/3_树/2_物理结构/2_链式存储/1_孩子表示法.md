##  孩子表示法
使用 多重链表法 : 一个结点包含它 所有 子树的指针

* 所有结点的 指针数量 == 树的度
使用链式存储
统一 但**浪费空间**
结点：
```shell
[data][son][son]...[son]
```

* 结点的 指针数量 == 它自己的子树数量
使用链式存储
充分利用空间 但有**时间损耗**
```shell
[data][儿子的数量][son][son]...[son]
```

###   孩子表示法
充分利用空间 并 减少时间损耗
使用 顺序存储+链式存储（**数组**+**链表**）

* 顺序存储
数组存储所有结点
结点：
```shell
[data][第一个孩子的指针]
```

* 链式存储
数组的所有元素 像是一个链表的 头结点
链表里的结点   都是 头结点的子树
```shell
[data][第一个孩子的指针] ->	[孩子在数组中的索引][下一个孩子的指针] ->
...
[data][第一个孩子的指针] ->
```


###   改进
* 问题
找结点的双亲麻烦

* 解决
顺序存储中的结点 添加双亲字段
```shell
[data][双亲][第一个孩子的指针]
```

